# https://github.com/Motion-Project/motion/issues/1460
# https://gist.github.com/Mr-Dave/0f89cdcf10f3863301bbe19c0f3d0aea
# https://gist.githubusercontent.com/Mr-Dave/0f89cdcf10f3863301bbe19c0f3d0aea/raw/c0b8cf6b83112194bc1c28d074ab0ef022d709c9/gistfile1.txt

index 10e8366..cf2b9dd 100644
--- src/ffmpeg.c.orig
+++ src/ffmpeg.c
@@ -175,6 +175,73 @@ static void ffmpeg_free_context(struct ffmpeg *ffmpeg)
 
 }
 
+struct blacklist_t
+{
+    const char *codec_name;
+    const char *reason;
+};
+
+static const char *ffmpeg_codec_is_blacklisted(const char *codec_name)
+{
+
+    static struct blacklist_t blacklisted_codec[] =
+    {
+    #if ( MYFFVER < 58029)
+            /* h264_omx & ffmpeg combination locks up on Raspberry Pi.
+            * Newer versions of ffmpeg allow zerocopy to be disabled to workaround
+            * this issue.
+            * To use h264_omx encoder on older versions of ffmpeg:
+            * - disable input_zerocopy in ffmpeg omx.c:omx_encode_init function.
+            * - remove the "h264_omx" from this blacklist.
+            * More information: https://github.com/Motion-Project/motion/issues/433
+            */
+            {"h264_omx", "Codec causes lock up on your FFMpeg version"},
+    #endif
+    #if ( MYFFVER < 57041)
+            {"h264_v4l2m2m", "FFMpeg version is too old"},
+    #endif
+    };
+    size_t i, i_mx;
+
+    i_mx = (size_t)(sizeof(blacklisted_codec)/sizeof(blacklisted_codec[0]));
+
+    for (i = 0; i < i_mx; i++) {
+        if (mystreq(codec_name, blacklisted_codec[i].codec_name)) {
+            return blacklisted_codec[i].reason;
+        }
+    }
+    return NULL;
+}
+
+static int ffmpeg_get_codec_preferred(struct ffmpeg *ffmpeg)
+{
+    my_AVCodec *codec;
+    int ret_id;
+    size_t codec_name_len = strcspn(ffmpeg->codec_name, ":");
+
+    ret_id = -1;
+    if (ffmpeg->codec_name[codec_name_len]) {
+        const char *blacklist_reason = ffmpeg_codec_is_blacklisted(&ffmpeg->codec_name[codec_name_len+1]);
+        if (blacklist_reason) {
+            MOTION_LOG(WRN, TYPE_ENCODER, NO_ERRNO
+                ,_("Preferred codec %s has been blacklisted: %s")
+                ,&ffmpeg->codec_name[codec_name_len+1], blacklist_reason);
+        } else {
+            codec = avcodec_find_encoder_by_name(&ffmpeg->codec_name[codec_name_len+1]);
+            if (codec != NULL) {
+                ret_id = codec->id;
+            } else if (ffmpeg->codec == NULL) {
+                MOTION_LOG(WRN, TYPE_ENCODER, NO_ERRNO
+                    ,_("Preferred codec %s not found")
+                    ,&ffmpeg->codec_name[codec_name_len+1]);
+            }
+        }
+    }
+
+    return ret_id;
+}
+
+
 static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
 {
 
@@ -220,7 +287,7 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
     if (ffmpeg->tlapse == TIMELAPSE_APPEND) {
         ffmpeg->oc->oformat = av_guess_format ("mpeg2video", NULL, NULL);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_MPEG2VIDEO;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_MPEG2VIDEO;
         }
 
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.mpg",basename);
@@ -244,7 +311,7 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         ffmpeg->oc->oformat = av_guess_format("avi", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.avi",basename);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_MSMPEG4V2;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_MSMPEG4V2;
         }
     }
 
@@ -257,7 +324,7 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         ffmpeg->oc->oformat = av_guess_format("flv", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.flv",basename);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_FLV1;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_FLV1;
         }
     }
 
@@ -265,7 +332,7 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         ffmpeg->oc->oformat = av_guess_format("avi", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.avi",basename);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_FFV1;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_FFV1;
         }
     }
 
@@ -278,7 +345,7 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         ffmpeg->oc->oformat = av_guess_format("mp4", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.mp4",basename);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_H264;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_H264;
         }
     }
 
@@ -286,14 +353,14 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         ffmpeg->oc->oformat = av_guess_format("matroska", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.mkv",basename);
         if (ffmpeg->oc->oformat) {
-            ffmpeg->oc->video_codec_id = MY_CODEC_ID_H264;
+            ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_H264;
         }
     }
 
     if (mystreq(codec_name, "hevc")) {
         ffmpeg->oc->oformat = av_guess_format("mp4", NULL, NULL);
         retcd = snprintf(ffmpeg->filename,PATH_MAX,"%s.mp4",basename);
-        ffmpeg->oc->video_codec_id = MY_CODEC_ID_HEVC;
+        ffmpeg->oc->oformat->video_codec = MY_CODEC_ID_HEVC;
     }
 
     //Check for valid results
@@ -313,6 +380,13 @@ static int ffmpeg_get_oformat(struct ffmpeg *ffmpeg)
         return -1;
     }
 
+    retcd = ffmpeg_get_codec_preferred(ffmpeg);
+    if (retcd != -1) {
+        ffmpeg->oc->oformat->video_codec = retcd;
+        MOTION_LOG(NTC, TYPE_ENCODER, NO_ERRNO
+            ,_("Using preferred codec id %d"),retcd);
+    }
+
     if (ffmpeg->oc->oformat->video_codec == MY_CODEC_ID_NONE) {
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, _("Could not get the codec"));
         ffmpeg_free_context(ffmpeg);
@@ -570,76 +644,24 @@ static int ffmpeg_set_quality(struct ffmpeg *ffmpeg)
     return 0;
 }
 
-struct blacklist_t
-{
-    const char *codec_name;
-    const char *reason;
-};
-
-static const char *ffmpeg_codec_is_blacklisted(const char *codec_name)
+static int ffmpeg_set_codec(struct ffmpeg *ffmpeg)
 {
+    int retcd;
+    char errstr[128];
+    int chkrate;
 
-    static struct blacklist_t blacklisted_codec[] =
-    {
-    #if ( MYFFVER < 58029)
-            /* h264_omx & ffmpeg combination locks up on Raspberry Pi.
-            * Newer versions of ffmpeg allow zerocopy to be disabled to workaround
-            * this issue.
-            * To use h264_omx encoder on older versions of ffmpeg:
-            * - disable input_zerocopy in ffmpeg omx.c:omx_encode_init function.
-            * - remove the "h264_omx" from this blacklist.
-            * More information: https://github.com/Motion-Project/motion/issues/433
-            */
-            {"h264_omx", "Codec causes lock up on your FFMpeg version"},
-    #endif
-    #if ( MYFFVER < 57041)
-            {"h264_v4l2m2m", "FFMpeg version is too old"},
-    #endif
-    };
-    size_t i, i_mx;
-
-    i_mx = (size_t)(sizeof(blacklisted_codec)/sizeof(blacklisted_codec[0]));
-
-    for (i = 0; i < i_mx; i++) {
-        if (mystreq(codec_name, blacklisted_codec[i].codec_name)) {
-            return blacklisted_codec[i].reason;
-        }
-    }
-    return NULL;
-}
-
-static int ffmpeg_set_codec_preferred(struct ffmpeg *ffmpeg)
-{
-    size_t codec_name_len = strcspn(ffmpeg->codec_name, ":");
+    //retcd = ffmpeg_set_codec_preferred(ffmpeg);
+    //if (retcd != 0) {
+    //    return retcd;
+    //}
 
-    ffmpeg->codec = NULL;
-    if (ffmpeg->codec_name[codec_name_len]) {
-        const char *blacklist_reason = ffmpeg_codec_is_blacklisted(&ffmpeg->codec_name[codec_name_len+1]);
-        if (blacklist_reason) {
-            MOTION_LOG(WRN, TYPE_ENCODER, NO_ERRNO
-                ,_("Preferred codec %s has been blacklisted: %s")
-                ,&ffmpeg->codec_name[codec_name_len+1], blacklist_reason);
-        } else {
-            ffmpeg->codec = avcodec_find_encoder_by_name(&ffmpeg->codec_name[codec_name_len+1]);
-            if ((ffmpeg->oc->oformat) && (ffmpeg->codec != NULL)) {
-                    ffmpeg->oc->video_codec_id = ffmpeg->codec->id;
-            } else if (ffmpeg->codec == NULL) {
-                MOTION_LOG(WRN, TYPE_ENCODER, NO_ERRNO
-                    ,_("Preferred codec %s not found")
-                    ,&ffmpeg->codec_name[codec_name_len+1]);
-            }
-        }
-    }
-    if (!ffmpeg->codec) {
-        ffmpeg->codec = avcodec_find_encoder(ffmpeg->oc->oformat->video_codec);
-    }
+    ffmpeg->codec = avcodec_find_encoder(ffmpeg->oc->oformat->video_codec);
     if (!ffmpeg->codec) {
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO
             ,_("Codec %s not found"), ffmpeg->codec_name);
         ffmpeg_free_context(ffmpeg);
         return -1;
     }
-
     if (mystreq(ffmpeg->codec->name, "h264_v4l2m2m")) {
         ffmpeg->preferred_codec = USER_CODEC_V4L2M2M;
     } else if (mystreq(ffmpeg->codec->name, "h264_omx")) {
@@ -650,25 +672,8 @@ static int ffmpeg_set_codec_preferred(struct ffmpeg *ffmpeg)
         ffmpeg->preferred_codec = USER_CODEC_DEFAULT;
     }
 
-    if (ffmpeg->codec_name[codec_name_len]) {
-        MOTION_LOG(NTC, TYPE_ENCODER, NO_ERRNO,_("Using codec %s"), ffmpeg->codec->name);
-    }
-
-    return 0;
-
-}
-
-static int ffmpeg_set_codec(struct ffmpeg *ffmpeg)
-{
-
-    int retcd;
-    char errstr[128];
-    int chkrate;
-
-    retcd = ffmpeg_set_codec_preferred(ffmpeg);
-    if (retcd != 0) {
-        return retcd;
-    }
+    MOTION_LOG(NTC, TYPE_ENCODER, NO_ERRNO,_("Using codec %s %d")
+        , ffmpeg->codec->name, ffmpeg->codec->id);
 
     #if ( MYFFVER >= 57041)
         //If we provide the codec to this, it results in a memory leak.  ffmpeg ticket: 5714
